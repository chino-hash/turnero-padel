generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [pg_trgm, uuid_ossp(map: "uuid-ossp", schema: "public")]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@index([provider])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expires])
}

model User {
  id                String    @id @default(cuid())
  name              String?
  email             String    @unique
  emailVerified     DateTime?
  image             String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  fullName          String?
  phone             String?
  role              Role      @default(USER)
  isActive          Boolean   @default(true)
  lastLogin         DateTime?
  preferences       String    @default("{}")
  deletedAt         DateTime?
  accounts          Account[]
  bookings          Booking[]
  recurringBookings RecurringBooking[]
  paymentsProcessed Payment[] @relation("ProcessedBy")
  closedBookings    Booking[] @relation("ClosedBy")
  ventasProcesadas  Venta[]   @relation("ProcessedBy")
  sessions          Session[]

  @@index([email])
  @@index([role])
  @@index([isActive])
  @@index([createdAt])
  @@index([deletedAt])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Court {
  id              String    @id @default(cuid())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  name            String
  description     String?
  basePrice       Int
  priceMultiplier Float     @default(1.0)
  features        String
  isActive        Boolean   @default(true)
  operatingHours  String    @default("{\"start\": \"00:00\", \"end\": \"23:00\", \"slot_duration\": 90}")
  deletedAt       DateTime?
  bookings        Booking[]
  recurringBookings RecurringBooking[]

  @@index([isActive])
  @@index([name])
  @@index([deletedAt])
}

model Booking {
  id                 String          @id @default(cuid())
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  courtId            String
  userId             String
  bookingDate        DateTime
  startTime          String
  endTime            String
  durationMinutes    Int             @default(90)
  totalPrice         Int
  depositAmount      Int             @default(0)
  status             BookingStatus   @default(PENDING)
  paymentStatus      PaymentStatus   @default(PENDING)
  paymentMethod      PaymentMethod?
  expiresAt          DateTime?
  notes              String?
  cancelledAt        DateTime?
  cancellationReason String?
  closedAt           DateTime?
  closedById         String?
  deletedAt          DateTime?
  court              Court           @relation(fields: [courtId], references: [id])
  user               User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  closedBy           User?           @relation("ClosedBy", fields: [closedById], references: [id])
  players            BookingPlayer[]
  payments           Payment[]
  extras             BookingExtra[]
  recurringId        String?
  recurringBooking   RecurringBooking? @relation(fields: [recurringId], references: [id])

  @@unique([courtId, bookingDate, startTime, endTime])
  @@index([courtId, bookingDate])
  @@index([userId, bookingDate])
  @@index([status, bookingDate])
  @@index([paymentStatus])
  @@index([bookingDate, startTime])
  @@index([createdAt])
  @@index([deletedAt])
  @@index([closedAt])
  @@index([closedById])
  @@index([courtId, status, bookingDate])
  @@index([courtId, bookingDate, status, paymentStatus], map: "idx_booking_complex_search")
  @@index([courtId, bookingDate, startTime, endTime], map: "idx_booking_time_range")
  @@index([status, paymentStatus, createdAt], map: "idx_booking_status_reports")
  @@index([expiresAt])
  @@index([recurringId])
}

model BookingPlayer {
  id            String         @id @default(cuid())
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  bookingId     String
  playerName    String
  playerPhone   String?
  playerEmail   String?
  hasPaid       Boolean        @default(false)
  paidAmount    Int            @default(0)
  paidAt        DateTime?
  paymentMethod PaymentMethod?
  position      Int?
  notes         String?
  deletedAt     DateTime?
  booking       Booking        @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  payments      Payment[]
  extras        BookingExtra[]

  @@unique([bookingId, position])
  @@index([bookingId])
  @@index([hasPaid])
  @@index([playerEmail])
  @@index([deletedAt])
}

model Payment {
  id              String         @id @default(cuid())
  createdAt       DateTime       @default(now())
  bookingId       String
  playerId        String?
  processedById   String?
  amount          Int
  paymentMethod   PaymentMethod
  paymentType     PaymentType    @default(PAYMENT)
  referenceNumber String?
  notes           String?
  status          String         @default("completed")
  deletedAt       DateTime?
  updatedAt       DateTime       @updatedAt
  booking         Booking        @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  player          BookingPlayer? @relation(fields: [playerId], references: [id], onDelete: Cascade)
  processedBy     User?          @relation("ProcessedBy", fields: [processedById], references: [id])

  @@index([bookingId])
  @@index([playerId])
  @@index([processedById])
  @@index([paymentMethod])
  @@index([paymentType])
  @@index([status])
  @@index([createdAt])
  @@index([referenceNumber])
  @@index([deletedAt])
  @@index([createdAt, status, paymentMethod, amount], map: "idx_payment_reports")
  @@index([paymentMethod, paymentType, createdAt], map: "idx_payment_analytics")
}

model SystemSetting {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  key         String   @unique
  value       String
  description String?
  category    String   @default("general")
  isPublic    Boolean  @default(false)
}

model Producto {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  nombre    String
  precio    Float
  stock     Int      @default(0)
  categoria String
  activo    Boolean  @default(true)
  extras    BookingExtra[]
  ventas    Venta[]

  @@index([categoria])
  @@index([activo])
}

model BookingExtra {
  id            String         @id @default(cuid())
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  bookingId     String
  playerId      String?
  productoId    Int
  quantity      Int            @default(1)
  unitPrice     Float
  totalPrice    Float
  assignedToAll Boolean        @default(false)
  notes         String?
  deletedAt     DateTime?

  booking       Booking        @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  player        BookingPlayer? @relation(fields: [playerId], references: [id], onDelete: Cascade)
  producto      Producto       @relation(fields: [productoId], references: [id])

  @@index([bookingId])
  @@index([playerId])
  @@index([productoId])
  @@index([deletedAt])
}

model AdminWhitelist {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String   @unique
  isActive  Boolean  @default(true)
  addedBy   String?
  notes     String?

  @@index([email])
  @@index([isActive])
}

model AdminNotification {
  id          String   @id @default(cuid())
  type        String   // 'PAYMENT_CONFLICT', 'REFUND_FAILED', 'SYSTEM_ERROR', etc.
  severity    String   @default("info") // 'info', 'warning', 'error', 'critical'
  title       String
  message     String
  metadata    Json?    // Datos adicionales (bookingId, paymentId, etc.)
  read        Boolean  @default(false)
  readAt      DateTime?
  readBy      String?  // Email del admin que leyó
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([type])
  @@index([severity])
  @@index([read])
  @@index([createdAt])
}

enum Role {
  USER
  ADMIN
}

enum BookingStatus {
  PENDING
  CONFIRMED
  ACTIVE
  COMPLETED
  CANCELLED
  PAYMENT_CONFLICT
}

enum PaymentStatus {
  PENDING
  DEPOSIT_PAID
  FULLY_PAID
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CARD
}

enum PaymentType {
  PAYMENT
  REFUND
  ADJUSTMENT
}
model RecurringBooking {
  id          String         @id @default(cuid())
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  courtId     String
  userId      String
  weekday     Int            // 0 (domingo) - 6 (sábado)
  startTime   String
  endTime     String
  status      RecurringStatus @default(ACTIVE)
  startsAt    DateTime
  endsAt      DateTime?
  notes       String?

  court       Court          @relation(fields: [courtId], references: [id])
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookings    Booking[]
  exceptions  RecurringBookingException[]

  @@index([courtId, weekday, startTime, status])
}

enum RecurringStatus {
  ACTIVE
  PAUSED
  CANCELLED
}

enum ExceptionType {
  SKIP
  OVERRIDE
}

model RecurringBookingException {
  id          Int             @id @default(autoincrement())
  createdAt   DateTime        @default(now())
  recurringId String
  date        DateTime        // solo fecha (UTC normalizado)
  type        ExceptionType
  reason      String?
  newPrice    Float?

  recurring   RecurringBooking @relation(fields: [recurringId], references: [id], onDelete: Cascade)

  @@index([recurringId, date])
}

model Venta {
  id            String         @id @default(cuid())
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  productoId    Int
  quantity      Int            @default(1)
  unitPrice     Float
  totalPrice    Float
  paymentMethod PaymentMethod
  processedById String?
  notes         String?

  producto      Producto       @relation(fields: [productoId], references: [id])
  processedBy   User?          @relation("ProcessedBy", fields: [processedById], references: [id])

  @@index([productoId])
  @@index([processedById])
  @@index([paymentMethod])
  @@index([createdAt])
}
