generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
  extensions = [pg_trgm]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId]) // Cuentas por usuario
  @@index([provider]) // Filtrar por proveedor
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId]) // Sesiones por usuario
  @@index([expires]) // Limpiar sesiones expiradas
}

model User {
  id                String    @id @default(cuid())
  name              String?
  email             String    @unique
  emailVerified     DateTime?
  image             String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  deletedAt         DateTime? // Soft delete
  fullName          String?
  phone             String?
  role              Role      @default(USER)
  isActive          Boolean   @default(true)
  lastLogin         DateTime?
  preferences       String    @default("{}")
  accounts          Account[]
  bookings          Booking[]
  paymentsProcessed Payment[] @relation("ProcessedBy")
  sessions          Session[]

  @@index([email])
  @@index([role])
  @@index([isActive])
  @@index([createdAt])
  @@index([deletedAt])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Court {
  id              String    @id @default(cuid())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime? // Soft delete
  name            String
  description     String?
  basePrice       Int
  priceMultiplier Float     @default(1.0)
  features        String
  isActive        Boolean   @default(true)
  operatingHours  String    @default("{\"start\": \"00:00\", \"end\": \"23:00\", \"slot_duration\": 90}")
  bookings        Booking[]

  @@index([isActive])
  @@index([name])
  @@index([deletedAt])
}

model Booking {
  id                 String          @id @default(cuid())
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  deletedAt          DateTime?       // Soft delete
  courtId            String
  userId             String
  bookingDate        DateTime
  startTime          String
  endTime            String
  durationMinutes    Int             @default(90)
  totalPrice         Int
  depositAmount      Int             @default(0)
  status             BookingStatus   @default(PENDING)
  paymentStatus      PaymentStatus   @default(PENDING)
  paymentMethod      PaymentMethod?
  notes              String?
  cancelledAt        DateTime?
  cancellationReason String?
  court              Court           @relation(fields: [courtId], references: [id])
  user               User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  players            BookingPlayer[]
  payments           Payment[]

  @@unique([courtId, bookingDate, startTime, endTime])
  // Índices para consultas frecuentes
  @@index([courtId, bookingDate]) // Disponibilidad por cancha y fecha
  @@index([userId, bookingDate]) // Reservas del usuario por fecha
  @@index([status, bookingDate]) // Filtrar por estado y fecha
  @@index([paymentStatus]) // Filtrar por estado de pago
  @@index([bookingDate, startTime]) // Ordenar por fecha y hora
  @@index([createdAt]) // Ordenar por fecha de creación
  @@index([deletedAt]) // Soft delete queries
  @@index([courtId, status, bookingDate]) // Consulta compuesta frecuente
}

model BookingPlayer {
  id            String         @id @default(cuid())
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  deletedAt     DateTime?      // Soft delete
  bookingId     String
  playerName    String
  playerPhone   String?
  playerEmail   String?
  hasPaid       Boolean        @default(false)
  paidAmount    Int            @default(0)
  paidAt        DateTime?
  paymentMethod PaymentMethod?
  position      Int?
  notes         String?
  booking       Booking        @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  payments      Payment[]

  @@unique([bookingId, position])
  @@index([bookingId]) // Consultas por reserva
  @@index([hasPaid]) // Filtrar por estado de pago
  @@index([playerEmail]) // Buscar por email
  @@index([deletedAt]) // Soft delete queries
}

model Payment {
  id              String         @id @default(cuid())
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  deletedAt       DateTime?      // Soft delete
  bookingId       String
  playerId        String?
  processedById   String?
  amount          Int
  paymentMethod   PaymentMethod
  paymentType     PaymentType    @default(PAYMENT)
  referenceNumber String?
  notes           String?
  status          String         @default("completed")
  booking         Booking        @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  player          BookingPlayer? @relation(fields: [playerId], references: [id], onDelete: Cascade)
  processedBy     User?          @relation("ProcessedBy", fields: [processedById], references: [id])

  @@index([bookingId]) // Pagos por reserva
  @@index([playerId]) // Pagos por jugador
  @@index([processedById]) // Pagos procesados por usuario
  @@index([paymentMethod]) // Filtrar por método de pago
  @@index([paymentType]) // Filtrar por tipo de pago
  @@index([status]) // Filtrar por estado
  @@index([createdAt]) // Ordenar por fecha
  @@index([referenceNumber]) // Buscar por número de referencia
  @@index([deletedAt]) // Soft delete queries
}

model SystemSetting {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  key         String   @unique
  value       String
  description String?
  category    String   @default("general")
  isPublic    Boolean  @default(false)
}

model Producto {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  nombre    String
  precio    Float
  stock     Int      @default(0)
  categoria String
  activo    Boolean  @default(true)

  @@index([categoria])
  @@index([activo])
}

model AdminWhitelist {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String   @unique
  isActive  Boolean  @default(true)
  addedBy   String?
  notes     String?

  @@index([email])
  @@index([isActive])
}

enum Role {
  USER
  ADMIN
}

enum BookingStatus {
  PENDING
  CONFIRMED
  ACTIVE
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  DEPOSIT_PAID
  FULLY_PAID
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CARD
}

enum PaymentType {
  PAYMENT
  REFUND
  ADJUSTMENT
}
